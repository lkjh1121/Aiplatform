import numpy as np 

a = [1,2,3,4,5,6,7,8,9,10] #list
aa = np.array(a) #ndarray

#a[0:5]=9 #list타입은 지원하지 않는다 
print(a)
print(type(a))

aa[0:5] = 8  #브로드캐스팅 
print( aa )
print(type(aa))

#feature, 특성, 독립변수 
#target, label, 결과, 종속변수       - 종류                                     

#파이썬은 2차원이 없다. list타입 
#2차원 형태로 데이터를 넣고 싶다. list of list 
a = [ [1,2,3], 
      [4,5,6] ]
print(a[0])
print(a[1])

a2 = np.array(a)
print(a2)

#배열 - 연속된 공간 데이터 백만개 - 단일한 공간으로 백만개 들어갈
#       공간이 있어야 한다. 
#       실제 데이터가 한개도 들어왔다가 두개도  들어왔다가 
#       백만개가 들어와도 백만개가 무조건 필요하다 
#       필요가 있던 없던 고정이다. 정해진 크기가 들어오면 빠르다

#a : 1 2 3 4 5 6 7 8 9 10

#링크드리스트 - 잘라서 작은공간들을 연결해서 저장하자 
#       한개가 두개가 필요할지 100만개가 필요할지 아무도 모른다 
#       (데이터와 +다음번 데이터의 주소) 
#       데이터놓고 다음번 요소 주소넣고  반복하며 만든다 
#       전체 메모리는 이게 더 많이 차지 
#       데이터를 중간에 넣고 빼는데 편하다.       
#a : (1|주소)->(2|주소)->(3|주소)->(4|주소)->(5|주소)->(6|주소)->(7|)->(8|)->(9|)->(10|)->
#파이썬의 list다 

a1 = np.arange(1, 11, 2)
print(a1, type(a1))

#소프트카피와 하드카피 
#소프트카피가 기본임, 
word1=["사과", "배", "오렌지", "수박", "참외"] #list타입 
#파이썬은 모든 변수에 데이터 자체는 저장을 못하고 데이터 번지를 저장한다

word2=word1#복사를 한다 , 번지만 복사한다. 그래서 동일한 데이터공간
          #을 갖고 있다. 
word2[0]="키위"
print( word1 )
print( word2 )

word3 = word2.copy() #하드카피, 별도의 데이터 공간을 확보한 후 
                     #데이터를 옮긴다
word3[0]="자몽"
print( word1 )
print( word2 )
print( word3 )

n1 = np.zeros( (2,4) ) #값을 tuple타입으로 줘야 한다 
                       #2 by 4 행렬을 만들고 0으로 채운다.

print(n1)
n1 = np.ones( (2,4) ) 
print(n1)

#조건식 부여하기 

a = np.arange(1, 11)
print(type(a))
print(a)
print( a > 5) #벡터 연산을 해서, a에 있는 모든 요소들에 
# >5 비교 연산을 수행하여 결과를 벡터로 내놓는다 

print( a[ a> 5] ) # True 라고 되어 있는 데이터의 집합(벡터)만 내놓는다

#행렬의 곱
a = [[1,2,3], [4,5,6]] #앞행열의 열의개수가 
b = [ [7,8], [9, 10], [11, 12]] #뒤행렬의 행의 개수가 같을 때 행렬의 곱

aa = np.array(a)
bb = np.array(b)

result = aa.dot(bb)

print( result )
